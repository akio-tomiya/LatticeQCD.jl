module LTK_universe
    using LinearAlgebra
    #export Universe
    

    import ..Gaugefields:GaugeFields,GaugeFields_1d,
                        IdentityGauges,RandomGauges,
                        set_wing!,
                        substitute!,
                        calc_GaugeAction,
                        SU3GaugeFields,SU3GaugeFields_1d,
                        SU2GaugeFields,SU2GaugeFields_1d,
                        Oneinstanton
    import ..Gaugefields
                        
    import ..Fermionfields:FermionFields,WilsonFermion,StaggeredFermion,substitute_fermion!
    import ..Fermionfields
    import ..Actions:GaugeActionParam,FermiActionParam,
                Setup_Gauge_action,Setup_Fermi_action,
                GaugeActionParam_standard,FermiActionParam_Wilson,
                show_parameters_action,
                FermiActionParam_WilsonClover,
                FermiActionParam_Staggered,
                GaugeActionParam_autogenerator
    import ..LieAlgebrafields:LieAlgebraFields,clear!,add_gaugeforce!
    import ..LieAlgebrafields
    import ..Rand:Random_LCGs
    import ..System_parameters:Params
    import ..Diracoperators:DdagD_operator
    import ..Wilsonloops:make_loopforactions
    import ..Verbose_print:Verbose_level,Verbose_3,Verbose_2,Verbose_1
    import ..IOmodule:loadU


    """
    Your universe is described in this type.
    """
    struct Universe{Gauge,Lie,Fermi,GaugeP,FermiP,Gauge_temp}
        NX::Int64
        NY::Int64
        NZ::Int64
        NT::Int64
        NV::Int64
        NC::Int64
        Nwing::Int64
        Dirac_operator::Union{Nothing,String}
        U::Array{Gauge,1}
        Uold::Array{Gauge,1}
        p::Array{Lie,1}
        φ::Union{Nothing,Fermi}
        ξ::Union{Nothing,Fermi}
        η::Union{Nothing,Fermi}
        gparam::GaugeP
        fparam::Union{Nothing,FermiP}
        BoundaryCondition::Array{Int8,1}
        initial::String
        quench::Bool
        NDFALG::Int64

        
        
        

        _temporal_gauge::Array{Gauge_temp,1}
        _temporal_fermi::Union{Nothing,Array{Fermi,1}}
        _temporal_algebra::Array{Lie,1}
        ranf::Random_LCGs
        verboselevel::Int8
        kind_of_verboselevel::Verbose_level

    end





    function set_β!(univ::Universe,β)
        if typeof(univ.gparam) == GaugeActionParam_standard 
            univ.gparam.β = β
            #univ.gparam = GaugeActionParam_standard(β,univ.gparam.NTRACE)
        elseif typeof(univ.gparam) == GaugeActionParam_autogenerator
            #univ.gparam =GaugeActionParam_autogenerator(univ.gparam.βs * (univ.gparam.β/β),β,univ.gparam.numactions,univ.gparam.NTRACE,univ.gparam.loops,univ.gparam.staples)
            univ.gparam.β = β
            univ.gparam.βs .= 0#univ.gparam.βs * (univ.gparam.β/β)
            univ.gparam.βs[1] = β
        else
            error("$(typeof(univ.gparam)) is not supported!")
        end
    end

    function set_β!(univ::Universe,βs::Array{T,1}) where T <: Number
        if typeof(univ.gparam) == GaugeActionParam_standard 
            univ.gparam.β = βs[1]
            #univ.gparam = GaugeActionParam_standard(β,univ.gparam.NTRACE)
        elseif typeof(univ.gparam) == GaugeActionParam_autogenerator
            @assert length(univ.gparam.βs) == length(βs) "univ.gparam.βs = $(univ.gparam.βs) and βs = $βs"
            #univ.gparam =GaugeActionParam_autogenerator(univ.gparam.βs * (univ.gparam.β/β),β,univ.gparam.numactions,univ.gparam.NTRACE,univ.gparam.loops,univ.gparam.staples)
            univ.gparam.β = βs[1]
            univ.gparam.βs .= βs
            #univ.gparam.βs = univ.gparam.βs * (univ.gparam.β/β)
        else
            error("$(typeof(univ.gparam)) is not supported!")
        end
    end

    function get_β(univ::Universe)
        if typeof(univ.gparam) == GaugeActionParam_standard 
            return univ.gparam.β
        elseif typeof(univ.gparam) == GaugeActionParam_autogenerator
            return univ.gparam.β
        else
            error("$(typeof(univ.gparam)) is not supported!")
        end
    end

    function set_βs!(univ::Universe,βs)
        if typeof(univ.gparam) == GaugeActionParam_standard 
            univ.gparam.β = βs[1]
        elseif typeof(univ.gparam) == GaugeActionParam_autogenerator
            univ.gparam.β = βs[1]
            univ.gparam.βs = βs[:]
        else
            error("$(typeof(univ.gparam)) is not supported!")
        end
    end


    include("default.jl")

    function Universe()
        file = "default.jl"
        return Universe(file)
    end

    function Universe(p::Params)
        L = p.L
        β = p.β
        NTRACE = p.NC
        if p.use_autogeneratedstaples 
            loops = make_loopforactions(p.couplinglist,L)
            gparam = GaugeActionParam_autogenerator(p.couplingcoeff,loops,p.NC,p.couplinglist)
        else
            gparam =  GaugeActionParam_standard(β,NTRACE)
        end

        if p.Dirac_operator == nothing
            fparam = nothing
        else
            if p.Dirac_operator == "Wilson"
                fparam = FermiActionParam_Wilson(p.hop,p.r,p.eps,p.Dirac_operator,p.MaxCGstep,p.quench)
            elseif p.Dirac_operator == "WilsonClover"
                #if p.NC == 2
                #    error("You use NC = 2. But WilsonClover Fermion is not supported in SU2 gauge theory yet. Use NC = 3.")
                #end
                NV = prod(p.L)
                #CloverFμν = zeros(ComplexF64,p.NC,p.NC,NV,6)
                inn_table= zeros(Int64,NV,4,2)
                internal_flags = zeros(Bool,2)
                _ftmp_vectors = Array{Array{ComplexF64,3},1}(undef,6)
                for i=1:6
                    _ftmp_vectors[i] = zeros(ComplexF64,p.NC,NV,4)
                end

                _is1 = zeros(Int64,NV)
                _is2 = zeros(Int64,NV)

                #fparam = FermiActionParam_WilsonClover(p.hop,p.r,p.eps,p.Dirac_operator,p.MaxCGstep,p.Clover_coefficient,CloverFμν,
                #                internal_flags,inn_table,_ftmp_vectors,_is1,_is2,
                #                p.quench)
                fparam = FermiActionParam_WilsonClover(p.hop,p.r,p.eps,p.Dirac_operator,p.MaxCGstep,p.Clover_coefficient,
                                internal_flags,inn_table,_ftmp_vectors,_is1,_is2,
                                p.quench)
            elseif p.Dirac_operator == "Staggered"
                fparam = FermiActionParam_Staggered(p.mass,p.eps,p.Dirac_operator,p.MaxCGstep,p.quench,p.Nf)
            else
                error(p.Dirac_operator," is not supported!")
            end
        end


        univ = Universe(L,gparam,p.Nwing,fparam,p.BoundaryCondition,p.initial,p.NC,p.verboselevel)

    end




    """
    ```Universe(file)```
    - file: file name of the input file.

    Make your universe. The input file is loaded.

    Undefined parameters in your input file are defined with the default values.

    The default values are as follows.

    ```julia
        L = (4,4,4,4)
        β = 6
        NTRACE = 3
        #gparam = Setup_Gauge_action(β)
        gparam =  GaugeActionParam_standard(β,NTRACE)

        BoundaryCondition=[1,1,1,-1]
        Nwing = 1
        initial="cold"
        NC =3


        hop= 0.141139 #Hopping parameter
        r= 1 #Wilson term
        eps= 1e-19
        Dirac_operator= "Wilson"
        MaxCGstep= 3000

        fparam = FermiActionParam_Wilson(hop,r,eps,Dirac_operator,MaxCGstep)

    ```
    """
    function Universe(file)
        if file != "default.jl"
            include(pwd()*"/"*file)
        end
        univ = Universe(L,gparam,Nwing,fparam,BoundaryCondition,initial,NC)

    end

    function show_parameters(univ::Universe)
        println("""
            L = $((univ.NX,univ.NY,univ.NZ,univ.NT))
            """)

        show_parameters_action(univ.gparam)

        println("""
            BoundaryCondition= $(univ.BoundaryCondition)
            Nwing = $(univ.Nwing)
            initial= $(univ.initial)
            NC =$(univ.NC)
            """)

        if univ.fparam != nothing
            show_parameters_action(univ.fparam)
        end
    end

    """
    ```Universe(L::Tuple,gparam::GaugeActionParam,initial="cold",fparam=nothing)```

    - L: system size (NX,NY,NZ,NT)
    - gparam: parameters for gauge actions
    - [initial]: initial Gauge configuration
    - [fparam]: parameters for fermion actions
    """
    function Universe(L::Tuple,gparam::GaugeActionParam,initial="cold",fparam=nothing)
        Nwing = 1
        BoundaryCondition=[1,1,1,-1]
        NC =3
        Universe(L,gparam,Nwing,fparam,BoundaryCondition,initial,NC)
    end


    function Universe(L,gparam,Nwing,fparam,BoundaryCondition,initial,NC,verboselevel)
        #(L::Tuple,gparam::GaugeActionParam;
        #   Nwing = 1,fparam=nothing,
        #  BoundaryCondition=[1,1,1,-1],initial="cold",NC =3)

        if verboselevel == 1
            kind_of_verboselevel = Verbose_1()
        elseif verboselevel == 2
            kind_of_verboselevel = Verbose_2()
        elseif verboselevel == 3
            kind_of_verboselevel = Verbose_3()
        end


        ranf = Random_LCGs(1)

        NX = L[1]
        NY = L[2]
        NZ = L[3]
        NT = L[4]
        NV = NX*NY*NZ*NT
        NDFALG = NC^2-1
        num_tempfield_g = 5
        num_tempfield_f = 4

        if fparam != nothing && fparam.Dirac_operator == "WilsonClover"
            num_tempfield_g += 4+4+8+8
        elseif fparam != nothing # && fparam.Dirac_operator == "Staggered"
            num_tempfield_f += 4
        end

        if typeof(gparam) == GaugeActionParam_autogenerator
            num_tempfield_g += 1
        end
        

        if NC == 3
            U = Array{SU3GaugeFields,1}(undef,4)
            _temporal_gauge = Array{SU3GaugeFields_1d,1}(undef,num_tempfield_g)
        elseif NC == 2
            U = Array{SU2GaugeFields,1}(undef,4)
            _temporal_gauge = Array{SU2GaugeFields_1d,1}(undef,num_tempfield_g)
        end
        
#        Uold = Array{GaugeFields,1}(undef,4)

        p = Array{LieAlgebraFields,1}(undef,4)
        for μ=1:4
            p[μ] = LieAlgebraFields(NC,NX,NY,NZ,NT)
        end

        if initial == "cold"
            println(".....  Cold start")
            for μ=1:4
                U[μ] = IdentityGauges(NC,NX,NY,NZ,NT,Nwing)
            end
        elseif initial == "hot"
            println(".....  Hot start")
            for μ=1:4
                U[μ] = RandomGauges(NC,NX,NY,NZ,NT,Nwing)
            end
        elseif initial == "one instanton"
            @assert NC == 2 "From one instanton start, NC should be 2!"
            U = Oneinstanton(NC,NX,NY,NZ,NT,Nwing)

        else #if initial == "file"
            println(".....  File start")
            println("File name is $initial")
            U = loadU(initial,NX,NY,NZ,NT,NC)
            #error("not supported yet.")
        end

        set_wing!(U)
        Uold = similar(U)
        substitute!(Uold,U)

        
        #=
        for μ=1:4
            set_wing!(U[μ])
            Uold[μ] = similar(U[μ])
            substitute!(Uold[μ],U[μ])
        end
        =#

        
        #_temporal_gauge = Array{GaugeFields,1}(undef,4)
        for i=1:length(_temporal_gauge)
            _temporal_gauge[i] = GaugeFields_1d(NC,NX,NY,NZ,NT) #similar(U[1])
            #_temporal_gauge[i] = similar(U[1])
        end

        _temporal_algebra = Array{LieAlgebraFields,1}(undef,1)
        for i=1:length(_temporal_algebra)
            _temporal_algebra[i] = similar(p[1])
        end


        if fparam == nothing
            Dirac_operator = nothing
            φ = nothing
            η = nothing
            ξ = nothing
            _temporal_fermi = nothing
            quench = true
        else
            Dirac_operator = fparam.Dirac_operator
            φ = FermionFields(NC,NX,NY,NZ,NT,fparam,BoundaryCondition)
            η = similar(φ)
            ξ = similar(φ)
            _temporal_fermi = Array{FermionFields,1}(undef,num_tempfield_f )
            for i=1:length(_temporal_fermi)
                _temporal_fermi[i] = similar(φ)
            end
            quench = fparam.quench

        end

        

        Gauge =eltype(U)
        Fermi = typeof(φ)
        Lie = eltype(p)
        GaugeP = typeof(gparam)
        FermiP = typeof(fparam)
        Gauge_temp = eltype(_temporal_gauge)



        return Universe{Gauge,Lie,Fermi,GaugeP,FermiP,Gauge_temp}(
            NX,
            NY,
            NZ,
            NT,
            NV,
            NC,
            Nwing,
            Dirac_operator,
            U,
            Uold,
            p,
            φ,
            ξ,
            η,
            gparam,
            fparam,
            BoundaryCondition,
            initial,
            quench,
            NDFALG,
            _temporal_gauge,
            _temporal_fermi,
            _temporal_algebra,
            ranf,
            verboselevel,
            kind_of_verboselevel
        )


    end

    function gauss_distribution(univ::Universe,nv) 
        variance = 1
        nvh = div(nv,2)
        granf = zeros(Float64,nv)
        for i=1:nvh
            rho = sqrt(-2*log(univ.ranf())*variance)
            theta = 2pi*univ.ranf()
            granf[i] = rho*cos(theta)
            granf[i+nvh] = rho*sin(theta)
        end
        if 2*nvh == nv
            return granf
        end

        granf[nv] = sqrt(-2*log(univ.ranf())*variance) * cos(2pi*univ.ranf())
        return granf
    end

    function expF_U!(U::Array{T,1},F::Array{N,1},Δτ,univ::Universe) where {T<: GaugeFields, N <: LieAlgebraFields} 
        LieAlgebrafields.expF_U!(U,F,Δτ,univ._temporal_gauge,univ._temporal_algebra[1])
    end

    function calc_gaugeforce!(F::Array{N,1},univ::Universe) where N <: LieAlgebraFields
        clear!(F)
        add_gaugeforce!(F,univ.U,univ._temporal_gauge,univ._temporal_algebra[1]) 
        return
    end

    function calc_gaugeforce!(F::Array{N,1},U::Array{T,1},univ::Universe) where {N<: LieAlgebraFields, T<: GaugeFields} 
        clear!(F)
        add_gaugeforce!(F,U,univ._temporal_gauge,univ._temporal_algebra[1]) 
        return
    end

    function Gaugefields.calc_GaugeAction(univ::Universe)
        Sg,plaq = calc_GaugeAction(univ.U,univ.gparam,univ._temporal_gauge)
        return real(Sg),real(plaq)
    end

    function calc_Action(univ::Universe)
        Sg,plaq = calc_GaugeAction(univ.U,univ.gparam,univ._temporal_gauge)
        
        SP = univ.p*univ.p/2
        #println("ek = $SP")
        S = Sg + SP
        #println("eym = $plaq")
        #println("e = $S")

        if univ.quench == false
        #if univ.fparam != nothing
            Sf = univ.η*univ.η
            S += Sf
        end
        return real(S),real(plaq)
    end

    

    function make_WdagWmatrix(univ::Universe)
        return make_WdagWmatrix(univ.U,univ._temporal_fermi,univ.fparam)
    end

    function make_WdagWmatrix(univ::Universe,U::Array{T,1}) where T <: GaugeFields
        return make_WdagWmatrix(U,univ._temporal_fermi,univ.fparam)
    end

    

    function make_WdagWmatrix(U::Array{G,1},temps::Array{T,1},fparam) where {G <: GaugeFields,T <:FermionFields}
        x0 = temps[7]
        xi = temps[8]
        Fermionfields.clear!(x0)
        NX = x0.NX
        NY = x0.NY
        NZ = x0.NZ
        NT = x0.NT
        NC = x0.NC
        if T == StaggeredFermion
            NG = 1
        else
            NG = 4
        end
        Nsize = NX*NY*NZ*NT*NC*NG
        WdagW = zeros(ComplexF64,Nsize,Nsize)
        WdagWoperator = DdagD_operator(U,x0,fparam)
        
        
        j = 0
        for α=1:NG
            for it=1:NT
                for iz=1:NZ
                    for iy=1:NY
                        for ix=1:NX
                            for ic=1:NC
                                Fermionfields.clear!(x0)
                                j += 1
                                x0[ic,ix,iy,iz,it,α] = 1
                                #set_wing_fermi!(x0)
                                
                                #WdagWx!(xi,U,x0,temps,fparam)
                                #println(xi*xi)

                                #Wx!(xi,U,x0,temps,fparam)
                                #println(xi*xi)

                                #Wx!(xi,U,x0,temps,fparam,(ix,iy,iz,it,α))
                                #println(xi*xi)
                                
                                mul!(xi,WdagWoperator,x0,(ix,iy,iz,it,α))
                                #WdagWx!(xi,U,x0,temps,fparam,(ix,iy,iz,it,α))
                                #println("fast ",xi*xi)
                                #exit()
                                #display(xi)
                                #exit()
                                substitute_fermion!(WdagW,j,xi)
                        
                            end
                        end
                    end
                end
            end            
        end


        return WdagW

    end


end