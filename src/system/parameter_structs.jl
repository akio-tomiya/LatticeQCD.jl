module Parameter_structs
using REPL.TerminalMenus
@enum SmearingMethod Nosmearing = 1 STOUT = 2

Base.@kwdef mutable struct Action
    use_autogeneratedstaples::Bool = false
    couplinglist::Vector{String} = []
    couplingcoeff::Vector{ComplexF64} = []
end

Base.@kwdef mutable struct MD
    MDsteps::Int64 = 20
    Δτ::Float64 = 1/20
    SextonWeingargten::Bool = false
    N_SextonWeingargten::Int64 = 2
end

abstract type Smearing_parameters end

Base.@kwdef mutable struct NoSmearing_parameters <: Smearing_parameters end

const kindsof_loops = [
    "plaquette",
    "rectangular",
    "chair",
    "polyakov_x",
    "polyakov_y",
    "polyakov_z",
    "polyakov_t",
]

Base.@kwdef mutable struct Stout_parameters <: Smearing_parameters
    numlayers::Int64 = 1
    ρ::Vector{Float64} = []
    stout_loops::Vector{String} = []
end

abstract type Fermion_parameters end

Base.@kwdef mutable struct Quench_parameters <: Fermion_parameters end

Base.@kwdef mutable struct Wilson_parameters <: Fermion_parameters
    hop::Float64 = 0.141139
    r::Float64 = 1
    Clover_coefficient::Float64 = 1.5612
end

Base.@kwdef mutable struct Staggered_parameters <: Fermion_parameters
    mass::Float64 = 0.5 #mass
    Nf::Int64 = 2 #flavor 
end

Base.@kwdef mutable struct Domainwall_parameters <: Fermion_parameters
    N5::Int64 = 4
    M::Float64 = -1 #mass for Wilson operator which should be negative
    m::Float64 = 0.1 #physical mass
end

Base.@kwdef mutable struct ConjugateGradient
    eps::Float64 = 1e-19
    MaxCGstep::Int64 = 3000
end

abstract type Measurement_parameters end

Base.@kwdef mutable struct Measurement_common_parameters
    methodname::String = ""
    measure_every::Int64 = 10
    fermiontype::String= "nothing"
end

Base.@kwdef mutable struct Plaq_parameters  <: Measurement_parameters
    common::Measurement_common_parameters = Measurement_common_parameters()
end

Base.@kwdef mutable struct Poly_parameters  <: Measurement_parameters
    common::Measurement_common_parameters = Measurement_common_parameters()
end

Base.@kwdef mutable struct TopologicalCharge_parameters  <: Measurement_parameters
    common::Measurement_common_parameters = Measurement_common_parameters()
    numflow::Int64 = 1 #number of flows
    Nflowsteps::Int64 = 1
    eps_flow::Float64  = 0.01
end

Base.@kwdef mutable struct ChiralCondensate_parameters  <: Measurement_parameters
    common::Measurement_common_parameters = Measurement_common_parameters()
    fermiontype::String = "Staggered"
    Nf::Int64 = 4
    eps::Float64 = 1e-19
    mass::Float64 = 0.5
    MaxCGstep::Int64 = 3000
    smearing_for_fermion::String = "nothing"
    smearing::Smearing_parameters = Stout_parameters()
end

Base.@kwdef mutable struct Pion_parameters  <: Measurement_parameters
    common::Measurement_common_parameters = Measurement_common_parameters()
    fermiontype::String = "Wilson"
    eps::Float64 = 1e-19
    MaxCGstep::Int64 = 3000
    smearing_for_fermion::String = "nothing"
    smearing::Smearing_parameters = NoSmearing_parameters()
    fermion_parameters::Fermion_parameters  = Wilson_parameters()
end

Base.@kwdef mutable struct System
    BoundaryCondition::Vector{Int64} = [1, 1, 1, -1]
    Nwing::Int8 = 1
    verboselevel::Int8 = 1
    randomseed::Int64 = 111
    L::NTuple{4,Int64} = (4, 4, 4, 4)
    NC::Int8 = 3
    β::Float64 = 5.7
    initialtrj::Int64 = 1
    loadU_format::Union{Nothing,String} = nothing
    update_method::String = "HMC"
    loadU_dir::Union{Nothing,String} = nothing
    loadU_fromfile::Bool = false
    loadU_filename::Union{Nothing,String} = nothing
    initial::String = "cold"
    Dirac_operator::Union{Nothing,String} = nothing
    quench::Bool = true
    smearing_for_fermion::String = "nothing"
    useOR::Bool = false #Over relaxation method for heatbath updates
    numOR::Int64 = 0 #number of Over relaxation method
    βeff::Float64 = 5.7 #effective beta for SLHMC
    firstlearn::Int64 = 1
    Nthermalization::Int64 = 0 #number of updates without measuring
    smearing::Smearing_parameters = NoSmearing_parameters()
    measurement_methods::Vector{Measurement_parameters} = []

end





function Plaq_parameters_interactive()
    method = Plaq_parameters()
    println("You measure Plaquette loops")
    method.common.methodname = "Plaquette"
    method.common.measure_every =
        parse(Int64, Base.prompt("How often measure Plaquette loops?", default = "1"))
    return method
end



function Poly_parameters_interactive()
    method = Poly_parameters()
    println("You measure Polyakov loops")
    method.common.methodname = "Polyakov_loop"
    method.common.measure_every =
        parse(Int64, Base.prompt("How often measure Polyakov loops?", default = "1"))
    return method
end



function TopologicalCharge_parameters_interactive()
    method = TopologicalCharge_parameters()
    println("You measure a topological charge")
    method.common.methodname = "Topological_charge"
    method.common.measure_every =
        parse(Int64, Base.prompt("How often measure a topological charge?", default = "1"))

    method.numflow = parse(
            Int64,
            Base.prompt(
                "How many times do you want to flow gauge fields to measure the topological charge?",
                default = "10",
    ),)

    Nflowsteps = 1#L[1]
    eps_flow = 0.01
    
    method.Nflowsteps = parse(Int64, Base.prompt("Nflowsteps?", default = "$Nflowsteps"))
    method.eps_flow = parse(Float64, Base.prompt("eps_flow?", default = "$eps_flow"))
        
    return method
end








function MD_interactive(;Dirac_operator=nothing)
    md = MD()
    println("Choose parameters for MD")
    MDsteps = parse(Int64, Base.prompt("Input MD steps", default = "20"))
    Δτ = parse(Float64, Base.prompt("Input Δτ", default = "$(1/MDsteps)"))
    md.MDsteps = MDsteps
    md.Δτ = Δτ

    if Dirac_operator != nothing
        SW = request(
                "Use SextonWeingargten method? multi-time scale",
                RadioMenu(["false", "true"]),
            )
        SextonWeingargten = ifelse(SW == 1, false, true)

        if SextonWeingargten
            N_SextonWeingargten = parse(
                Int64,
                Base.prompt("Input number of SextonWeingargten steps", default = "2"),
            )
        else
            N_SextonWeingargten = 2
        end
        md.SextonWeingargten = SextonWeingargten
        md.N_SextonWeingargten = N_SextonWeingargten
    end
    return md

end





function Stout_parameters_interactive()
    stout = Stout_parameters()

    stout_menu = MultiSelectMenu(kindsof_loops)
    choices =
        request("Select the kinds of loops you want to add in stout smearing:", stout_menu)
    count = 0
    ρs = Float64[]
    loops = String[]
    for i in choices
        count += 1
        ρ = parse(
            Float64,
            Base.prompt("coefficient ρ for $(kindsof_loops[i]) loop?", default = "0.1"),
        )
        push!(ρs, ρ)
        push!(loops, kindsof_loops[i])
    end
    stout.ρ = ρs
    stout.stout_loops = loops

    return stout
end





function CG_params_interactive()
    cg = ConjugateGradient()
    eps = parse(Float64, Base.prompt("relative error in CG loops", default = "1e-19"))
    MaxCGstep =
        parse(Int64, Base.prompt("Maximum iteration steps in CG loops", default = "3000"))
    if eps <= 0
        error("Invalid value for eps=$eps. This has to be strictly positive.")
    end
    if MaxCGstep <= 0
        error("Invalid value for MaxCGstep=$MaxCGstep. This has to be strictly positive.")
    end
    cg.eps = eps
    cg.MaxCGstep = MaxCGstep
    return cg
end




function ChiralCondensate_parameters_interactive(;mass= 0.5)
    method = ChiralCondensate_parameters()
    println("You measure chiral condensates with the statteggred fermion")
    method.common.methodname = "Chiral_condensate"
    method.common.measure_every =
        parse(Int64, Base.prompt("How often measure chiral condensates?", default = "1"))
    method.mass = parse(
        Float64,
        Base.prompt(
            "Input mass for the measurement of chiral condensates",
            default = "$mass",
        ),
    )

    method.Nf = 4
    println(
        "Number of flavors (tastes) for the measurement of chiral condensates is $(method.Nf)",
    )

    eps = parse(Float64, Base.prompt("relative error in CG loops", default = "1e-19"))
    MaxCGstep =
        parse(Int64, Base.prompt("Maximum iteration steps in CG loops", default = "3000"))
    if eps <= 0
        error("Invalid value for eps=$eps. This has to be strictly positive.")
    end
    if MaxCGstep <= 0
        error("Invalid value for MaxCGstep=$MaxCGstep. This has to be strictly positive.")
    end
    method.eps = eps
    method.MaxCGstep = MaxCGstep

    smearing =
            request(
                "Choose a configuration format for loading",
                RadioMenu(["No smearing", "stout smearing"]),
            ) |> SmearingMethod

    if smearing == Nosmearing
        method.smearing_for_fermion = "nothing"
        method.smearing = NoSmearing_parameters()
    elseif smearing == STOUT
        method.system.smearing_for_fermion = "stout"
        method.smearing = Stout_parameters_interactive()
    end

    return method
end




function Pion_parameters_interactive()
    method = Pion_parameters()
    println("You measure Pion_correlator")
    method.common.methodname = "Pion_correlator"
    method.common.measure_every =
        parse(Int64, Base.prompt("How often measure Pion_correlator?", default = "1"))

    wtype = request(
        "Choose fermion type for the measurement of Pion_correlator",
        RadioMenu([
            "Standard Wilson fermion action",
            "Wilson+Clover fermion action",
            "Staggered fermion action",
        ]),
    )

    if wtype == 1
        println("Standard Wilson fermion action will be used for the measurement")
        method.fermiontype = "Wilson"
        fermion_parameters, cg = wilson_wizard()
    elseif wtype == 2
        println("Wilson+Clover fermion action will be used for the measurement")
        method.fermiontype = "WilsonClover"
        fermion_parameters, cg = wilson_wizard()
    elseif wtype == 3
        println("Staggered fermion action will be used for the measurement")
        method.fermiontype = "Staggered"
        fermion_parameters, cg = staggered_wizard()
    end

    method.eps = cg.eps
    method.MaxCGstep = cg.MaxCGstep

    smearing =
            request(
                "Choose a configuration format for loading",
                RadioMenu(["No smearing", "stout smearing"]),
            ) |> SmearingMethod

    if smearing == Nosmearing
        method.smearing_for_fermion = "nothing"
        method.smearing = NoSmearing_parameters()
    elseif smearing == STOUT
        method.smearing_for_fermion = "stout"
        method.smearing = Stout_parameters_interactive()
    end

    return method
end



function wilson_wizard()
    fermion_parameters = Wilson_parameters()

    hop = parse(Float64, Base.prompt("Input the hopping parameter κ", default = "0.141139"))
    #hop = parse(Float64,readline(stdin))
    if hop <= 0
        error("Invalid value for κ=$hop. This has to be strictly positive.")
    end
    println("κ = $hop")
    fermion_parameters.hop = hop

    cg = CG_params_interactive()

    return fermion_parameters, cg
end

function staggered_wizard()
    staggered = Staggered_parameters()
    mass = parse(Float64, Base.prompt("Input mass", default = "0.5"))
    if mass <= 0
        error("Invalid value for mass=$mass. This has to be strictly positive.")
    end
    staggered.mass = mass

    Nftype = request(
        "Choose the number of flavors(tastes)",
        RadioMenu([
            "2 (RHMC will be used)",
            "3 (RHMC will be used)",
            "4 (HMC will be used)",
            "8 (HMC will be used)",
            "1 (RHMC will be used)",
        ]),
    )

    if Nftype == 1
        Nf = 2
    elseif Nftype == 2
        Nf = 3
    elseif Nftype == 3
        Nf = 4
    elseif Nftype == 4
        Nf = 8
    elseif Nftype == 5
        Nf = 1
    end

    staggerd.Nf = Nf

    cg = CG_params_interactive()

    return staggered, cg

end

function Domainwall_wizard()
    fermion_parameters = Domainwall_parameters()
    N5 =
        parse(Int64, Base.prompt("Input the size of the extra dimension L5", default = "4"))
    fermion_parameters.N5 =  N5
    println("Standard Domainwall fermion action is uded")

    M = parse(Float64, Base.prompt("Input M", default = "-1"))
    while M >= 0
        println("M should be M < 0. ")
        M = parse(Float64, Base.prompt("Input M", default = "-1"))
    end
    fermion_parameters.M = M

    m = parse(Float64, Base.prompt("Input mass", default = "1"))
    fermion_parameters.m = m

    cg = CG_params_interactive()
    return fermion_parameters,cg
end



end
